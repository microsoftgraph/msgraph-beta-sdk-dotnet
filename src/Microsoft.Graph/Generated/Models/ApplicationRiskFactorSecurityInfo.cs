// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using Microsoft.Kiota.Abstractions.Store;
using Microsoft.Kiota.Abstractions;
using System.Collections.Generic;
using System.IO;
using System;
namespace Microsoft.Graph.Beta.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class ApplicationRiskFactorSecurityInfo : IAdditionalDataHolder, IBackedModel, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData
        {
            get { return BackingStore.Get<IDictionary<string, object>>("AdditionalData") ?? new Dictionary<string, object>(); }
            set { BackingStore.Set("AdditionalData", value); }
        }
        /// <summary>Stores model information.</summary>
        public IBackingStore BackingStore { get; private set; }
        /// <summary>The certificate property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo? Certificate
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo?>("certificate"); }
            set { BackingStore?.Set("certificate", value); }
        }
#nullable restore
#else
        public global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo Certificate
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo>("certificate"); }
            set { BackingStore?.Set("certificate", value); }
        }
#endif
        /// <summary>Specifies the domain or hostname evaluated during the security assessment.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? DomainToCheck
        {
            get { return BackingStore?.Get<string?>("domainToCheck"); }
            set { BackingStore?.Set("domainToCheck", value); }
        }
#nullable restore
#else
        public string DomainToCheck
        {
            get { return BackingStore?.Get<string>("domainToCheck"); }
            set { BackingStore?.Set("domainToCheck", value); }
        }
#endif
        /// <summary>Indicates whether the application maintains an audit trail for administrative actions.</summary>
        public bool? HasAdminAuditTrail
        {
            get { return BackingStore?.Get<bool?>("hasAdminAuditTrail"); }
            set { BackingStore?.Set("hasAdminAuditTrail", value); }
        }
        /// <summary>Indicates whether the application allows anonymous or unauthenticated usage.</summary>
        public bool? HasAnonymousUsage
        {
            get { return BackingStore?.Get<bool?>("hasAnonymousUsage"); }
            set { BackingStore?.Set("hasAnonymousUsage", value); }
        }
        /// <summary>Indicates whether the application logs access or modification of customer data for audit purposes.</summary>
        public bool? HasDataAuditTrail
        {
            get { return BackingStore?.Get<bool?>("hasDataAuditTrail"); }
            set { BackingStore?.Set("hasDataAuditTrail", value); }
        }
        /// <summary>Indicates whether the application classifies and labels data based on sensitivity levels.</summary>
        public bool? HasDataClassification
        {
            get { return BackingStore?.Get<bool?>("hasDataClassification"); }
            set { BackingStore?.Set("hasDataClassification", value); }
        }
        /// <summary>Indicates whether data at rest and in transit are encrypted using approved algorithms.</summary>
        public bool? HasDataEncrypted
        {
            get { return BackingStore?.Get<bool?>("hasDataEncrypted"); }
            set { BackingStore?.Set("hasDataEncrypted", value); }
        }
        /// <summary>Indicates whether HTTPS or equivalent secure transport is enforced for all communication channels.</summary>
        public bool? HasEnforceTransportEnc
        {
            get { return BackingStore?.Get<bool?>("hasEnforceTransportEnc"); }
            set { BackingStore?.Set("hasEnforceTransportEnc", value); }
        }
        /// <summary>Indicates whether access to the application can be restricted based on IP address or network range.</summary>
        public bool? HasIpRestriction
        {
            get { return BackingStore?.Get<bool?>("hasIpRestriction"); }
            set { BackingStore?.Set("hasIpRestriction", value); }
        }
        /// <summary>Indicates whether the application supports or enforces multi-factor authentication (MFA).</summary>
        public bool? HasMFA
        {
            get { return BackingStore?.Get<bool?>("hasMFA"); }
            set { BackingStore?.Set("hasMFA", value); }
        }
        /// <summary>Indicates whether the application undergoes periodic penetration testing or external security reviews.</summary>
        public bool? HasPenTest
        {
            get { return BackingStore?.Get<bool?>("hasPenTest"); }
            set { BackingStore?.Set("hasPenTest", value); }
        }
        /// <summary>Indicates whether the application supports password-saving functionality, which may pose a security risk.</summary>
        public bool? HasRememberPassword
        {
            get { return BackingStore?.Get<bool?>("hasRememberPassword"); }
            set { BackingStore?.Set("hasRememberPassword", value); }
        }
        /// <summary>Indicates whether the application supports SAML-based single sign-on (SSO).</summary>
        public bool? HasSamlSupport
        {
            get { return BackingStore?.Get<bool?>("hasSamlSupport"); }
            set { BackingStore?.Set("hasSamlSupport", value); }
        }
        /// <summary>Indicates whether user activity is logged for security or compliance monitoring.</summary>
        public bool? HasUserAuditLogs
        {
            get { return BackingStore?.Get<bool?>("hasUserAuditLogs"); }
            set { BackingStore?.Set("hasUserAuditLogs", value); }
        }
        /// <summary>Indicates whether users can upload or store personal or organizational data within the application.</summary>
        public bool? HasUserDataUpload
        {
            get { return BackingStore?.Get<bool?>("hasUserDataUpload"); }
            set { BackingStore?.Set("hasUserDataUpload", value); }
        }
        /// <summary>Indicates whether the application supports role-based access control (RBAC).</summary>
        public bool? HasUserRolesSupport
        {
            get { return BackingStore?.Get<bool?>("hasUserRolesSupport"); }
            set { BackingStore?.Set("hasUserRolesSupport", value); }
        }
        /// <summary>Indicates whether the certificate’s common name matches the application’s verified domain.</summary>
        public bool? HasValidCertName
        {
            get { return BackingStore?.Get<bool?>("hasValidCertName"); }
            set { BackingStore?.Set("hasValidCertName", value); }
        }
        /// <summary>Lists the HTTP security headers detected for the application (for example, HSTS, X-Frame-Options, or CSP).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? HttpsSecurityHeaders
        {
            get { return BackingStore?.Get<List<string>?>("httpsSecurityHeaders"); }
            set { BackingStore?.Set("httpsSecurityHeaders", value); }
        }
#nullable restore
#else
        public List<string> HttpsSecurityHeaders
        {
            get { return BackingStore?.Get<List<string>>("httpsSecurityHeaders"); }
            set { BackingStore?.Set("httpsSecurityHeaders", value); }
        }
#endif
        /// <summary>Indicates whether the application’s certificate is signed by a trusted certificate authority (CA).</summary>
        public bool? IsCertTrusted
        {
            get { return BackingStore?.Get<bool?>("isCertTrusted"); }
            set { BackingStore?.Set("isCertTrusted", value); }
        }
        /// <summary>Indicates whether the application is vulnerable to the DROWN (Decrypting RSA with Obsolete and Weakened eNcryption) attack.</summary>
        public bool? IsDrownVulnerable
        {
            get { return BackingStore?.Get<bool?>("isDrownVulnerable"); }
            set { BackingStore?.Set("isDrownVulnerable", value); }
        }
        /// <summary>Indicates whether the application’s SSL implementation is protected from the Heartbleed vulnerability.</summary>
        public bool? IsHeartbleedProof
        {
            get { return BackingStore?.Get<bool?>("isHeartbleedProof"); }
            set { BackingStore?.Set("isHeartbleedProof", value); }
        }
        /// <summary>Specifies the date of the last publicly reported data breach or security incident related to the application, if known.</summary>
        public Date? LastBreachDate
        {
            get { return BackingStore?.Get<Date?>("lastBreachDate"); }
            set { BackingStore?.Set("lastBreachDate", value); }
        }
        /// <summary>The latestValidSSL property</summary>
        public global::Microsoft.Graph.Beta.Models.SslVersion? LatestValidSSL
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.SslVersion?>("latestValidSSL"); }
            set { BackingStore?.Set("latestValidSSL", value); }
        }
        /// <summary>The OdataType property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? OdataType
        {
            get { return BackingStore?.Get<string?>("@odata.type"); }
            set { BackingStore?.Set("@odata.type", value); }
        }
#nullable restore
#else
        public string OdataType
        {
            get { return BackingStore?.Get<string>("@odata.type"); }
            set { BackingStore?.Set("@odata.type", value); }
        }
#endif
        /// <summary>The passwordPolicy property</summary>
        public global::Microsoft.Graph.Beta.Models.PasswordPolicy? PasswordPolicy
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.PasswordPolicy?>("passwordPolicy"); }
            set { BackingStore?.Set("passwordPolicy", value); }
        }
        /// <summary>The restEncryptionType property</summary>
        public global::Microsoft.Graph.Beta.Models.RestEncryptionType? RestEncryptionType
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.RestEncryptionType?>("restEncryptionType"); }
            set { BackingStore?.Set("restEncryptionType", value); }
        }
        /// <summary>
        /// Instantiates a new <see cref="global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorSecurityInfo"/> and sets the default values.
        /// </summary>
        public ApplicationRiskFactorSecurityInfo()
        {
            BackingStore = BackingStoreFactorySingleton.Instance.CreateBackingStore();
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorSecurityInfo"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorSecurityInfo CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorSecurityInfo();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "certificate", n => { Certificate = n.GetObjectValue<global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo>(global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo.CreateFromDiscriminatorValue); } },
                { "domainToCheck", n => { DomainToCheck = n.GetStringValue(); } },
                { "hasAdminAuditTrail", n => { HasAdminAuditTrail = n.GetBoolValue(); } },
                { "hasAnonymousUsage", n => { HasAnonymousUsage = n.GetBoolValue(); } },
                { "hasDataAuditTrail", n => { HasDataAuditTrail = n.GetBoolValue(); } },
                { "hasDataClassification", n => { HasDataClassification = n.GetBoolValue(); } },
                { "hasDataEncrypted", n => { HasDataEncrypted = n.GetBoolValue(); } },
                { "hasEnforceTransportEnc", n => { HasEnforceTransportEnc = n.GetBoolValue(); } },
                { "hasIpRestriction", n => { HasIpRestriction = n.GetBoolValue(); } },
                { "hasMFA", n => { HasMFA = n.GetBoolValue(); } },
                { "hasPenTest", n => { HasPenTest = n.GetBoolValue(); } },
                { "hasRememberPassword", n => { HasRememberPassword = n.GetBoolValue(); } },
                { "hasSamlSupport", n => { HasSamlSupport = n.GetBoolValue(); } },
                { "hasUserAuditLogs", n => { HasUserAuditLogs = n.GetBoolValue(); } },
                { "hasUserDataUpload", n => { HasUserDataUpload = n.GetBoolValue(); } },
                { "hasUserRolesSupport", n => { HasUserRolesSupport = n.GetBoolValue(); } },
                { "hasValidCertName", n => { HasValidCertName = n.GetBoolValue(); } },
                { "httpsSecurityHeaders", n => { HttpsSecurityHeaders = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "isCertTrusted", n => { IsCertTrusted = n.GetBoolValue(); } },
                { "isDrownVulnerable", n => { IsDrownVulnerable = n.GetBoolValue(); } },
                { "isHeartbleedProof", n => { IsHeartbleedProof = n.GetBoolValue(); } },
                { "lastBreachDate", n => { LastBreachDate = n.GetDateValue(); } },
                { "latestValidSSL", n => { LatestValidSSL = n.GetEnumValue<global::Microsoft.Graph.Beta.Models.SslVersion>(); } },
                { "@odata.type", n => { OdataType = n.GetStringValue(); } },
                { "passwordPolicy", n => { PasswordPolicy = n.GetEnumValue<global::Microsoft.Graph.Beta.Models.PasswordPolicy>(); } },
                { "restEncryptionType", n => { RestEncryptionType = n.GetEnumValue<global::Microsoft.Graph.Beta.Models.RestEncryptionType>(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteObjectValue<global::Microsoft.Graph.Beta.Models.ApplicationRiskFactorCertificateInfo>("certificate", Certificate);
            writer.WriteStringValue("domainToCheck", DomainToCheck);
            writer.WriteBoolValue("hasAdminAuditTrail", HasAdminAuditTrail);
            writer.WriteBoolValue("hasAnonymousUsage", HasAnonymousUsage);
            writer.WriteBoolValue("hasDataAuditTrail", HasDataAuditTrail);
            writer.WriteBoolValue("hasDataClassification", HasDataClassification);
            writer.WriteBoolValue("hasDataEncrypted", HasDataEncrypted);
            writer.WriteBoolValue("hasEnforceTransportEnc", HasEnforceTransportEnc);
            writer.WriteBoolValue("hasIpRestriction", HasIpRestriction);
            writer.WriteBoolValue("hasMFA", HasMFA);
            writer.WriteBoolValue("hasPenTest", HasPenTest);
            writer.WriteBoolValue("hasRememberPassword", HasRememberPassword);
            writer.WriteBoolValue("hasSamlSupport", HasSamlSupport);
            writer.WriteBoolValue("hasUserAuditLogs", HasUserAuditLogs);
            writer.WriteBoolValue("hasUserDataUpload", HasUserDataUpload);
            writer.WriteBoolValue("hasUserRolesSupport", HasUserRolesSupport);
            writer.WriteBoolValue("hasValidCertName", HasValidCertName);
            writer.WriteCollectionOfPrimitiveValues<string>("httpsSecurityHeaders", HttpsSecurityHeaders);
            writer.WriteBoolValue("isCertTrusted", IsCertTrusted);
            writer.WriteBoolValue("isDrownVulnerable", IsDrownVulnerable);
            writer.WriteBoolValue("isHeartbleedProof", IsHeartbleedProof);
            writer.WriteDateValue("lastBreachDate", LastBreachDate);
            writer.WriteEnumValue<global::Microsoft.Graph.Beta.Models.SslVersion>("latestValidSSL", LatestValidSSL);
            writer.WriteStringValue("@odata.type", OdataType);
            writer.WriteEnumValue<global::Microsoft.Graph.Beta.Models.PasswordPolicy>("passwordPolicy", PasswordPolicy);
            writer.WriteEnumValue<global::Microsoft.Graph.Beta.Models.RestEncryptionType>("restEncryptionType", RestEncryptionType);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
