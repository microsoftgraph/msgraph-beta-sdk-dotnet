// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Microsoft.Graph.Beta.Models
{
    /// <summary>
    /// Entity that represents a single Microsoft Tunnel server
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class MicrosoftTunnelServer : global::Microsoft.Graph.Beta.Models.Entity, IParsable
    {
        /// <summary>The digest of the current agent image running on this server. Supports: $filter, $select, $top, $skip, $orderby. $search is not supported. Read-only.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? AgentImageDigest
        {
            get { return BackingStore?.Get<string?>("agentImageDigest"); }
            set { BackingStore?.Set("agentImageDigest", value); }
        }
#nullable restore
#else
        public string AgentImageDigest
        {
            get { return BackingStore?.Get<string>("agentImageDigest"); }
            set { BackingStore?.Set("agentImageDigest", value); }
        }
#endif
        /// <summary>Microsoft Tunnel server deployment mode. The value is set when the server is registered. Possible values are standaloneRootful, standaloneRootless, podRootful, podRootless. Default value: standaloneRootful. Supports: $filter, $select, $top, $skip, $orderby. $search is not supported. Read-only. Possible values are: standaloneRootful, standaloneRootless, podRootful, podRootless, unknownFutureValue.</summary>
        public global::Microsoft.Graph.Beta.Models.MicrosoftTunnelDeploymentMode? DeploymentMode
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelDeploymentMode?>("deploymentMode"); }
            set { BackingStore?.Set("deploymentMode", value); }
        }
        /// <summary>The display name of the server. It is the same as the host name during registration and can be changed later. Supports: $filter, $select, $top, $skip, $orderby. $search is not supported. Max allowed length is 200 chars.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? DisplayName
        {
            get { return BackingStore?.Get<string?>("displayName"); }
            set { BackingStore?.Set("displayName", value); }
        }
#nullable restore
#else
        public string DisplayName
        {
            get { return BackingStore?.Get<string>("displayName"); }
            set { BackingStore?.Set("displayName", value); }
        }
#endif
        /// <summary>Indicates when the server last checked in. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: &apos;2014-01-01T00:00:00Z&apos;. Supports: $filter, $select, $top, $skip, $orderby. $search is not supported Read-only.</summary>
        public DateTimeOffset? LastCheckinDateTime
        {
            get { return BackingStore?.Get<DateTimeOffset?>("lastCheckinDateTime"); }
            set { BackingStore?.Set("lastCheckinDateTime", value); }
        }
        /// <summary>The digest of the current server image running on this server. Supports: $filter, $select, $top, $skip, $orderby. $search is not supported. Read-only.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ServerImageDigest
        {
            get { return BackingStore?.Get<string?>("serverImageDigest"); }
            set { BackingStore?.Set("serverImageDigest", value); }
        }
#nullable restore
#else
        public string ServerImageDigest
        {
            get { return BackingStore?.Get<string>("serverImageDigest"); }
            set { BackingStore?.Set("serverImageDigest", value); }
        }
#endif
        /// <summary>Enum of possible MicrosoftTunnelServer health status types</summary>
        public global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServerHealthStatus? TunnelServerHealthStatus
        {
            get { return BackingStore?.Get<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServerHealthStatus?>("tunnelServerHealthStatus"); }
            set { BackingStore?.Set("tunnelServerHealthStatus", value); }
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServer"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static new global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServer CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServer();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers())
            {
                { "agentImageDigest", n => { AgentImageDigest = n.GetStringValue(); } },
                { "deploymentMode", n => { DeploymentMode = n.GetEnumValue<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelDeploymentMode>(); } },
                { "displayName", n => { DisplayName = n.GetStringValue(); } },
                { "lastCheckinDateTime", n => { LastCheckinDateTime = n.GetDateTimeOffsetValue(); } },
                { "serverImageDigest", n => { ServerImageDigest = n.GetStringValue(); } },
                { "tunnelServerHealthStatus", n => { TunnelServerHealthStatus = n.GetEnumValue<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServerHealthStatus>(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public override void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            base.Serialize(writer);
            writer.WriteStringValue("agentImageDigest", AgentImageDigest);
            writer.WriteEnumValue<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelDeploymentMode>("deploymentMode", DeploymentMode);
            writer.WriteStringValue("displayName", DisplayName);
            writer.WriteDateTimeOffsetValue("lastCheckinDateTime", LastCheckinDateTime);
            writer.WriteStringValue("serverImageDigest", ServerImageDigest);
            writer.WriteEnumValue<global::Microsoft.Graph.Beta.Models.MicrosoftTunnelServerHealthStatus>("tunnelServerHealthStatus", TunnelServerHealthStatus);
        }
    }
}
#pragma warning restore CS0618
