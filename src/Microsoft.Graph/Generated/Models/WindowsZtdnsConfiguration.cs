// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Microsoft.Graph.Beta.Models
{
    /// <summary>
    /// Windows Zero Trust DNS configuration profile
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class WindowsZtdnsConfiguration : global::Microsoft.Graph.Beta.Models.DeviceConfiguration, IParsable
    {
        /// <summary>Indicates the audit operational mode. When true, unsecured traffic will be logged but not blocked. When false, unsecured DNS traffic will be blocked unless specifically exempted.</summary>
        public bool? AuditModeEnabled
        {
            get { return BackingStore?.Get<bool?>("auditModeEnabled"); }
            set { BackingStore?.Set("auditModeEnabled", value); }
        }
        /// <summary>Exemptions to the ZTDNS rules, allowing access to specific addresses or subnets via unsecured lookup. This collection can contain a maximum of 500 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule>? ExemptionRules
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule>?>("exemptionRules"); }
            set { BackingStore?.Set("exemptionRules", value); }
        }
#nullable restore
#else
        public List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule> ExemptionRules
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule>>("exemptionRules"); }
            set { BackingStore?.Set("exemptionRules", value); }
        }
#endif
        /// <summary>Extended key usage definitions for client authentication with secure DNS servers. This collection can contain a maximum of 500 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage>? ExtendedKeyUsagesForClientAuthentication
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage>?>("extendedKeyUsagesForClientAuthentication"); }
            set { BackingStore?.Set("extendedKeyUsagesForClientAuthentication", value); }
        }
#nullable restore
#else
        public List<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage> ExtendedKeyUsagesForClientAuthentication
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage>>("extendedKeyUsagesForClientAuthentication"); }
            set { BackingStore?.Set("extendedKeyUsagesForClientAuthentication", value); }
        }
#endif
        /// <summary>Indicates whether the DNS Client can resolve queries using the hosts file.</summary>
        public bool? HostsFileResolutionEnabled
        {
            get { return BackingStore?.Get<bool?>("hostsFileResolutionEnabled"); }
            set { BackingStore?.Set("hostsFileResolutionEnabled", value); }
        }
        /// <summary>Creates a localhost DNS server for securely forwarding plaintext queries to trusted DNS servers.</summary>
        public bool? LoopbackDnsForwarderEnabled
        {
            get { return BackingStore?.Get<bool?>("loopbackDnsForwarderEnabled"); }
            set { BackingStore?.Set("loopbackDnsForwarderEnabled", value); }
        }
        /// <summary>Indicates whether traffic to loopback addresses should be blocked.</summary>
        public bool? LoopbackTrafficBlocked
        {
            get { return BackingStore?.Get<bool?>("loopbackTrafficBlocked"); }
            set { BackingStore?.Set("loopbackTrafficBlocked", value); }
        }
        /// <summary>Maximum time in seconds for which connections to an IP address will be allowed after successful name resolution. Valid values 30 to 604800</summary>
        public int? MaximumConnectionTimeInSeconds
        {
            get { return BackingStore?.Get<int?>("maximumConnectionTimeInSeconds"); }
            set { BackingStore?.Set("maximumConnectionTimeInSeconds", value); }
        }
        /// <summary>Root certificates for client authentication. This collection can contain a maximum of 500 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>? RootCertificatesForClientValidation
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>?>("rootCertificatesForClientValidation"); }
            set { BackingStore?.Set("rootCertificatesForClientValidation", value); }
        }
#nullable restore
#else
        public List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate> RootCertificatesForClientValidation
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>>("rootCertificatesForClientValidation"); }
            set { BackingStore?.Set("rootCertificatesForClientValidation", value); }
        }
#endif
        /// <summary>Root certificates for server validation. This collection can contain a maximum of 500 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>? RootCertificatesForServerValidation
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>?>("rootCertificatesForServerValidation"); }
            set { BackingStore?.Set("rootCertificatesForServerValidation", value); }
        }
#nullable restore
#else
        public List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate> RootCertificatesForServerValidation
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>>("rootCertificatesForServerValidation"); }
            set { BackingStore?.Set("rootCertificatesForServerValidation", value); }
        }
#endif
        /// <summary>Collection of secure DNS servers used to resolve ZTDNS queries. Must contain at least one item. This collection can contain a maximum of 500 elements.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer>? SecureDnsServers
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer>?>("secureDnsServers"); }
            set { BackingStore?.Set("secureDnsServers", value); }
        }
#nullable restore
#else
        public List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer> SecureDnsServers
        {
            get { return BackingStore?.Get<List<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer>>("secureDnsServers"); }
            set { BackingStore?.Set("secureDnsServers", value); }
        }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Microsoft.Graph.Beta.Models.WindowsZtdnsConfiguration"/> and sets the default values.
        /// </summary>
        public WindowsZtdnsConfiguration() : base()
        {
            OdataType = "#microsoft.graph.windowsZtdnsConfiguration";
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Microsoft.Graph.Beta.Models.WindowsZtdnsConfiguration"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static new global::Microsoft.Graph.Beta.Models.WindowsZtdnsConfiguration CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::Microsoft.Graph.Beta.Models.WindowsZtdnsConfiguration();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public override IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>(base.GetFieldDeserializers())
            {
                { "auditModeEnabled", n => { AuditModeEnabled = n.GetBoolValue(); } },
                { "exemptionRules", n => { ExemptionRules = n.GetCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule>(global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule.CreateFromDiscriminatorValue)?.AsList(); } },
                { "extendedKeyUsagesForClientAuthentication", n => { ExtendedKeyUsagesForClientAuthentication = n.GetCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage>(global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage.CreateFromDiscriminatorValue)?.AsList(); } },
                { "hostsFileResolutionEnabled", n => { HostsFileResolutionEnabled = n.GetBoolValue(); } },
                { "loopbackDnsForwarderEnabled", n => { LoopbackDnsForwarderEnabled = n.GetBoolValue(); } },
                { "loopbackTrafficBlocked", n => { LoopbackTrafficBlocked = n.GetBoolValue(); } },
                { "maximumConnectionTimeInSeconds", n => { MaximumConnectionTimeInSeconds = n.GetIntValue(); } },
                { "rootCertificatesForClientValidation", n => { RootCertificatesForClientValidation = n.GetCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>(global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate.CreateFromDiscriminatorValue)?.AsList(); } },
                { "rootCertificatesForServerValidation", n => { RootCertificatesForServerValidation = n.GetCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>(global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate.CreateFromDiscriminatorValue)?.AsList(); } },
                { "secureDnsServers", n => { SecureDnsServers = n.GetCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer>(global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer.CreateFromDiscriminatorValue)?.AsList(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public override void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            base.Serialize(writer);
            writer.WriteBoolValue("auditModeEnabled", AuditModeEnabled);
            writer.WriteCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.WindowsZtdnsExemptionRule>("exemptionRules", ExemptionRules);
            writer.WriteCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.ExtendedKeyUsage>("extendedKeyUsagesForClientAuthentication", ExtendedKeyUsagesForClientAuthentication);
            writer.WriteBoolValue("hostsFileResolutionEnabled", HostsFileResolutionEnabled);
            writer.WriteBoolValue("loopbackDnsForwarderEnabled", LoopbackDnsForwarderEnabled);
            writer.WriteBoolValue("loopbackTrafficBlocked", LoopbackTrafficBlocked);
            writer.WriteIntValue("maximumConnectionTimeInSeconds", MaximumConnectionTimeInSeconds);
            writer.WriteCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>("rootCertificatesForClientValidation", RootCertificatesForClientValidation);
            writer.WriteCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.Windows81TrustedRootCertificate>("rootCertificatesForServerValidation", RootCertificatesForServerValidation);
            writer.WriteCollectionOfObjectValues<global::Microsoft.Graph.Beta.Models.WindowsZtdnsSecureDnsServer>("secureDnsServers", SecureDnsServers);
        }
    }
}
#pragma warning restore CS0618
